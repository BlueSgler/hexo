<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++文件操作</title>
    <url>/2021/02/06/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放。</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件的操作需要包含头文件<fstream></p>
<p>文件类型分为两种：</p>
<p>1.<strong>文本文件</strong>：文件以文本的ASII码形式存储在计算机中。</p>
<p>2.<strong>二进制文件</strong>：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们。</p>
<p>操作文件的三大类：</p>
<p>1.ofstream：写操作—-output（输出到文件中）</p>
<p>2.ifstream：读操作—–intput（输入到程序中）</p>
<p>3.fstream：读写操作</p>
<h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件步骤如下：</p>
<p>1.包含头文件</p>
<p>​    #include<ftream></p>
<p>2.创建流对象</p>
<p>​    ofstream ofs;</p>
<p>3.打开文件</p>
<p>​    ofs.open(“文件路径”，打开方式);</p>
<p>4.写数据</p>
<p>​    ofs &lt;&lt; “写入的数据”;</p>
<p>5.关闭文件</p>
<p>​    ofs.close();</p>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p>注意：文件操作可以配合使用，利用 | 操作符</p>
<p>例如：用二进制方式写文件  <code>ios::binary | ios ::out</code></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;创建流对象</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	</span><br><span class="line">	ofs.open(&quot;test.txt&quot;,ios::out);</span><br><span class="line">	ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;</span><br><span class="line">	ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	ofs.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开源文件所在目录，即可发现新创建的文本文件。</p>
<p><strong>总结：</strong></p>
<ul>
<li>文件操作必须包含头文件fstream</li>
<li>读文件可以利用ofstream，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式（只写文件名默认在和当前.cpp文件相同的路径下）</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>读文件与写文件步骤相似，但是读取方式相对较多</p>
<p>读文件步骤：</p>
<p>1.包含头文件</p>
<p>​    #include<fstream></p>
<p>2.创建流对象</p>
<p>​    ifstream ifs；</p>
<p>3.打开文件并判断文件是否打开成功</p>
<p>​    ifs.open(“文件路径”，打开方式)；</p>
<p>4.读数据</p>
<p>​    四种方式读取</p>
<p>5.关闭文件</p>
<p>​    ifs.close();</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.open(&quot;test.txt&quot;, ios::in);</span><br><span class="line">	if (!ifs.is_open())           &#x2F;&#x2F;打开失败返回假</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;文件打开失败!&quot; &lt;&lt; endl;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;第一种  会把空格输出成换行</span><br><span class="line">	&#x2F;*char buf[1024] &#x3D; &#123; 0 &#125;;</span><br><span class="line">	while (ifs &gt;&gt; buf)             &#x2F;&#x2F;一行一行读，读到头会返回一个假的标志</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;第二种  照常输出</span><br><span class="line">	&#x2F;*char buf[1024] &#x3D; &#123; 0 &#125;;</span><br><span class="line">	while (ifs.getline(buf, sizeof(buf)))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;第三种</span><br><span class="line">	&#x2F;*string buf;</span><br><span class="line"></span><br><span class="line">	while ( getline(ifs,buf ))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">	&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;第四种</span><br><span class="line">	char c;</span><br><span class="line">	&#x2F;&#x2F;如果没有读到文件尾就一直读下去。</span><br><span class="line">	while ((c &#x3D; ifs.get()) !&#x3D; EOF)      &#x2F;&#x2F;get一次只读一个字符</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; c;                      &#x2F;&#x2F;不要加endl，会出现乱码，它自己会读换行符</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>总结：</strong></p>
<ul>
<li>读文件可以利用ifstream，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件</li>
</ul>
<h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为ios::binary</p>
<h3 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h3><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>函数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	ofstream ofs;</span><br><span class="line">	ofs.open(&quot;person.txt&quot;, ios::out |ios::binary);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;上面两步可以合并为一步</span><br><span class="line">	&#x2F;*ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);*&#x2F;</span><br><span class="line"></span><br><span class="line">	Person p &#x3D; &#123; &quot;张三&quot;, 18 &#125;;            &#x2F;&#x2F;注意这里是大括号</span><br><span class="line">	ofs.write((const char*)&amp;p, sizeof(Person));</span><br><span class="line">	</span><br><span class="line">	ofs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>文件输出流对象，可以通过write函数，以二进制方式写数据</li>
</ul>
<h3 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h3><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>函数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;二进制文件最好不要用string类型，容易出问题</span><br><span class="line">	char m_Name[64];   </span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	ifstream ifs;</span><br><span class="line">	ifs.open(&quot;Person.txt&quot;, ios::in | ios::binary);</span><br><span class="line">	if (!ifs.is_open())</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;文件打开失败！&quot;&lt;&lt;endl;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	Person p;</span><br><span class="line">	ifs.read((char*)&amp;p, sizeof(Person));</span><br><span class="line">	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库的相关概念</title>
    <url>/2021/02/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<ul>
<li>DB  ——– （Database）:存储数据的“仓库”。它保存了一系列有组织的数据。</li>
<li>DBMS—–(Database Management System）数据库是通过DBMS创建和操作的容器</li>
<li>SQL——–（Structure Query Language）结构化查询语言，专门用来与数据库通信的语言</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库的相关概念</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2021/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2.栈和队列"></a>2.栈和队列</h2><h3 id="2-1-堆栈"><a href="#2-1-堆栈" class="headerlink" title="2.1 堆栈"></a>2.1 堆栈</h3><h4 id="2-1-1-顺序栈"><a href="#2-1-1-顺序栈" class="headerlink" title="2.1.1 顺序栈"></a>2.1.1 顺序栈</h4><p>​    <strong>1.栈的概念</strong></p>
<ul>
<li><p>​    栈（Stack）是操作受限的线性表，插入和删除数据元素的操作只能在线性表的一端进行。</p>
<p><strong>2.栈的主要操作</strong></p>
</li>
<li><p>入栈(Push)</p>
</li>
<li><p>出栈(Pop)</p>
</li>
</ul>
<p><img src="/noteimg/stack.png"></p>
<p>栈的操作特性：<strong>后进先出</strong>（Last In First Out, <strong>LIFO</strong> ）</p>
<ul>
<li>顺序栈———栈的顺序存储结构</li>
</ul>
<p>确定栈底：设top为栈顶元素索引（下标）</p>
<ul>
<li>栈的顺序存储结构及实现</li>
</ul>
<p>进栈：top先 + 1，然后在top指向的位置压入数据。</p>
<p>出栈：先top所指向的元素弹出，然后top - 1。</p>
<p>栈空：top = -1；</p>
<p>栈满：top = MAX_SIZE - 1;  PS：MAX_SIZE———栈的最大容量</p>
<p>上溢：栈顶指针或栈顶元素下标指出栈的外面。——-Push 时要先判断是否上溢</p>
<p>下溢：表示栈为空栈，却仍要执行弹栈操作。———–pop时要先判断是否下溢</p>
<p><strong>示例：</strong></p>
<p>字符类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_SIZE &#x3D; 100;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 定义栈类</span><br><span class="line">*&#x2F;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	char* data;            &#x2F;&#x2F;保存栈数组的首地址</span><br><span class="line">	int size;</span><br><span class="line">	int top;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Stack();</span><br><span class="line"></span><br><span class="line">	Stack(int s);</span><br><span class="line"></span><br><span class="line">	~Stack();</span><br><span class="line"></span><br><span class="line">	void push(char ch);  &#x2F;&#x2F;入栈</span><br><span class="line">	char Pop();              &#x2F;&#x2F;出栈，并返回栈顶元素</span><br><span class="line">	char getTop();         &#x2F;&#x2F;获得栈顶元素，不出栈</span><br><span class="line">	bool isEmpty();       &#x2F;&#x2F;判断栈是否为空</span><br><span class="line">	bool isFull();           &#x2F;&#x2F;判断栈是否满了</span><br><span class="line">	void setNull();        &#x2F;&#x2F;设置栈为空</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stack::Stack()</span><br><span class="line">&#123;</span><br><span class="line">	size &#x3D; MAX_SIZE;</span><br><span class="line">	top &#x3D; -1;</span><br><span class="line">	data &#x3D; new char[MAX_SIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack::Stack(int s)</span><br><span class="line">&#123;</span><br><span class="line">	size &#x3D; s;</span><br><span class="line">	top &#x3D; -1;</span><br><span class="line">	data &#x3D; new char[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">	delete[] data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Stack::setNull()</span><br><span class="line">&#123;</span><br><span class="line">	top &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Stack::push(char ch)</span><br><span class="line">&#123;</span><br><span class="line">	if (!isFull())</span><br><span class="line">	&#123;</span><br><span class="line">		top++;</span><br><span class="line">		data[top] &#x3D; ch;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char Stack::Pop()</span><br><span class="line">&#123;</span><br><span class="line">	if (!isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		return data[top--];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char Stack::getTop()</span><br><span class="line">&#123;</span><br><span class="line">	if (!isEmpty())</span><br><span class="line">	return data[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Stack::isEmpty()</span><br><span class="line">&#123;</span><br><span class="line">	if (top &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Stack::isFull()</span><br><span class="line">&#123;</span><br><span class="line">	if (top + 1 &#x3D;&#x3D; size)</span><br><span class="line">	&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;测试代码：</span><br><span class="line">	Stack s1(2);</span><br><span class="line"></span><br><span class="line">	s1.push(&#39;a&#39;);</span><br><span class="line">	s1.push(&#39;b&#39;);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; s1.isFull() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s1.getTop ()&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s1.Pop() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s1.Pop()&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s1.isEmpty() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h4 id="2-1-2-异常捕获优化顺序栈"><a href="#2-1-2-异常捕获优化顺序栈" class="headerlink" title="2.1.2 异常捕获优化顺序栈"></a>2.1.2 异常捕获优化顺序栈</h4><p><strong>C++异常处理</strong></p>
<ul>
<li><p>try…catch语句语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;try块包含可能抛出异常的语句</span><br><span class="line">try</span><br><span class="line">   &#123;</span><br><span class="line">	语句1;</span><br><span class="line">	语句2;</span><br><span class="line">	语句3;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;catch块捕获异常，但可以有多个，但至少有一个</span><br><span class="line">catch(异常类型)</span><br><span class="line">&#123;</span><br><span class="line">	异常处理代码</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">catch(异常类型)</span><br><span class="line">&#123;</span><br><span class="line">	异常处理代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>（1）try块语句在执行过程中没有抛出异常</li>
</ul>
<p>语句1,2,3均正常，则执行最后一个catch块后面的语句，所有catch块中的语句都不被执行。</p>
<ul>
<li>（2）try块执行的过程中抛出了异常（被捕获）</li>
</ul>
<p>如果语句2发生异常，那么抛出异常后立即跳转到第一个异常类型和抛出的异常类型匹配的catch块中执行。</p>
<p>语句3和try块中位于语句2下面的其他语句将会被跳过，不再执行。</p>
<ul>
<li>try块执行的过程中抛出了异常（未捕获）</li>
</ul>
<p>假设语句2发生异常，那么抛出异常，跳出try块，假设没有catch块可以捕获此错误，跳转到最后一个catch块后面的语句，造成程序终止。</p>
</li>
</ul>
<p><strong>什么时候会出现异常？</strong></p>
<ul>
<li><p>程序有错误会产生异常，eg：</p>
<ul>
<li>除法中分母是0；</li>
<li>用new运算动态分配内存空间时，空间不够导致无法分配；</li>
<li>访问数组元素，下标越界；</li>
<li>打开文件读取时，文件不存在。</li>
</ul>
</li>
<li><p>程序主动抛出异常，eg：</p>
<ul>
<li>用throw语句抛出异常，throw“栈空”</li>
</ul>
</li>
</ul>
<p><strong>自定义异常类的使用</strong></p>
<ul>
<li><p>定义异常内部类（在类的声明部分定义）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Empty&#123;&#125;;	&#x2F;&#x2F;在Stack类内部定义空类，大括号里面什么都没有</span><br></pre></td></tr></table></figure></li>
<li><p>抛出异常类（在pop函数遇到空栈时的语句）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw Empty();   &#x2F;&#x2F;注意这里是小括号</span><br></pre></td></tr></table></figure>

</li>
<li><p>捕获异常类（在调用pop函数时，用try/catch捕获）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">	stack.pop();   &#x2F;&#x2F;如果pop抛出来的类型是Empty类这个类型</span><br><span class="line">&#125;</span><br><span class="line">catch(Stack::Empty) &#x2F;&#x2F;输出提示语句</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;Stack Empty!!&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>优化顺序栈后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_SIZE &#x3D; 100;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 定义栈类</span><br><span class="line">*&#x2F;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	char* data;          &#x2F;&#x2F;保存栈数组的首地址</span><br><span class="line">	int size;</span><br><span class="line">	int top;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Stack();</span><br><span class="line"></span><br><span class="line">	Stack(int s);</span><br><span class="line"></span><br><span class="line">	~Stack();</span><br><span class="line"></span><br><span class="line">	void push(char ch);&#x2F;&#x2F;入栈</span><br><span class="line">	char Pop();        &#x2F;&#x2F;出栈，并返回栈顶元素</span><br><span class="line">	char getTop();     &#x2F;&#x2F;获得栈顶元素，不出栈</span><br><span class="line">	bool isEmpty();    &#x2F;&#x2F;判断栈是否为空</span><br><span class="line">	bool isFull();     &#x2F;&#x2F;判断栈是否满了</span><br><span class="line">	void setNull();    &#x2F;&#x2F;设置栈为空</span><br><span class="line">	class Full&#123;&#125;;	   &#x2F;&#x2F;声明异常对象Full类</span><br><span class="line">	class Empty&#123;&#125;;     &#x2F;&#x2F;声明异常对象Class类</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Stack::Stack()</span><br><span class="line">&#123;</span><br><span class="line">	size &#x3D; MAX_SIZE;</span><br><span class="line">	top &#x3D; -1;</span><br><span class="line">	data &#x3D; new char[MAX_SIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack::Stack(int s)</span><br><span class="line">&#123;</span><br><span class="line">	size &#x3D; s;</span><br><span class="line">	top &#x3D; -1;</span><br><span class="line">	data &#x3D; new char[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">	delete[] data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Stack::setNull()</span><br><span class="line">&#123;</span><br><span class="line">	top &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Stack::push(char ch)</span><br><span class="line">&#123;</span><br><span class="line">	if (isFull())   &#x2F;&#x2F;当栈满时，创建异常对象，并抛出</span><br><span class="line">	&#123;</span><br><span class="line">		throw Full();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		data[++top] &#x3D; ch;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char Stack::Pop()</span><br><span class="line">&#123;</span><br><span class="line">	if (isEmpty())  &#x2F;&#x2F;当栈空时，创建异常对象，并抛出</span><br><span class="line">	&#123;</span><br><span class="line">		throw Empty();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return data[top--];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char Stack::getTop()</span><br><span class="line">&#123;</span><br><span class="line">	if (!isEmpty())</span><br><span class="line">	return data[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Stack::isEmpty()</span><br><span class="line">&#123;</span><br><span class="line">	if (top &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Stack::isFull()</span><br><span class="line">&#123;</span><br><span class="line">	if (top + 1 &#x3D;&#x3D; size)</span><br><span class="line">	&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;测试代码：</span><br><span class="line">	Stack s1(2);</span><br><span class="line">	char ch;</span><br><span class="line"></span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		s1.push(&#39;a&#39;);</span><br><span class="line">		s1.push(&#39;b&#39;);</span><br><span class="line">		s1.push(&#39;c&#39;);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Stack::Full)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Stack Full!!!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		ch &#x3D; s1.Pop();</span><br><span class="line">		cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		ch &#x3D; s1.Pop();</span><br><span class="line">		cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		ch &#x3D; s1.Pop();</span><br><span class="line">		cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Stack::Empty)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Stack Empty!!!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>Stack Full!!!<br>b<br>a<br>Stack Empty!!!</p>
<p>分析：数组只定义了2个长度，却压入三个数据，当压入第三个数据时，执行创建Full类并抛出，被catch捕获，因此输出”Stack Full!!!”，结束执行pop函数，当弹出第2个元素以后，栈已经空了，但main函数中仍要弹出第三个数据，因此执行创建Empty类并抛出，被catch捕获输出“Stack Empty!!!”。</p>
<h4 id="2-1-3-用类模板实现顺序栈"><a href="#2-1-3-用类模板实现顺序栈" class="headerlink" title="2.1.3 用类模板实现顺序栈"></a>2.1.3 用类模板实现顺序栈</h4><ul>
<li><p>类模板是用于设计结构和成员函数完全相同，但所处理的数据类型不同的<strong>通用类</strong>。</p>
<p>类模板定义形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T1,class T2,...&gt;</span><br><span class="line">class 类名</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>编写通用的栈类</strong></p>
<p>将上面的代码声明部分改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class DataType&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	DataType* data;          &#x2F;&#x2F;保存栈数组的首地址</span><br><span class="line">	int size;</span><br><span class="line">	int top;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Stack();</span><br><span class="line"></span><br><span class="line">	Stack(int s);</span><br><span class="line"></span><br><span class="line">	~Stack();</span><br><span class="line"></span><br><span class="line">	void push(DataType e);&#x2F;&#x2F;入栈</span><br><span class="line">	DataType Pop();        &#x2F;&#x2F;出栈，并返回栈顶元素</span><br><span class="line">	DataType getTop();     &#x2F;&#x2F;获得栈顶元素，不出栈</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>成员函数每一项前加上 **<code>template&lt;class DataType&gt;</code>**，并把字符类型改为DataType，eg：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">	delete[] data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;入栈</span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">void Stack&lt;DataType&gt;::push(DataType ch)</span><br><span class="line">&#123;</span><br><span class="line">	if (isFull())   &#x2F;&#x2F;当栈满时，创建异常对象，并抛出</span><br><span class="line">	&#123;</span><br><span class="line">		throw Full();</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		data[++top] &#x3D; ch;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类模板</p>
<p>为了使用类模板对象，必须显示地指定模板参数，eg：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack&lt;char&gt; charStack;</span><br><span class="line">Stack&lt;int&gt; intStack;</span><br></pre></td></tr></table></figure>
<p>分别创建了charStack和intStack的堆栈对象。这两个堆栈对象分别可以处理字符类型和整数类型的数据。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习</title>
    <url>/2021/02/10/C-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h1><ul>
<li>C++泛型编程+STL技术</li>
</ul>
<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1.模板"></a>1.模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong>。</p>
<p>生活中类似月饼模具，ppt模板。</p>
<p>模板的特点：</p>
<ul>
<li>只是一个框架，不可直接使用</li>
<li>模板的通用不是万能的。</li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul>
<li><p>C++另一种编程思想称为 <strong>泛型编程</strong>，主要利用的技术就是模板。</p>
</li>
<li><p>C++提供两种模板机制： <strong>函数模板</strong>和<strong>类模板</strong></p>
</li>
</ul>
<h4 id="1-2-1函数模板语法"><a href="#1-2-1函数模板语法" class="headerlink" title="1.2.1函数模板语法"></a>1.2.1函数模板语法</h4><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">&#x2F;&#x2F;函数声明或定义</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p>template———声明创建模板</p>
<p>typename——-表面其后面的符号是一种数据类型，可以用class代替</p>
<p>​        T         ——通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<p>如果我们要实现两个整型数据的交换，我们写出以下函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swapInt(int &amp;a, int &amp;b)   &#x2F;&#x2F;用引用的方式传递，因此会交换本体</span><br><span class="line">&#123;</span><br><span class="line">	int temp &#x3D; a;</span><br><span class="line">	a &#x3D; b;</span><br><span class="line">	b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果我们要实现两个浮点型数据的交换，我们又要重新再写一个函数，如果我们还需要交换字符型函数，string类型函数，bool类型函数，自定义数据类型，是不是还需要再写n个函数来满足我们的需求，这样的话效率极低，而且每个函数只是数据类型不同，其他都基本相同，因此为了提高效率，提高函数的复用性，我们使用模板技术：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emplate&lt;typename T&gt; &#x2F;&#x2F;声明一个模板，T是一个通用数据类型</span><br><span class="line">void mySwap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp &#x3D; a;</span><br><span class="line">	a &#x3D; b;</span><br><span class="line">	b &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们应该如何使用模板呢，这里有2种办法：</p>
<ul>
<li><p>自动类型推导</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	int b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">	mySwap(a, b);  &#x2F;&#x2F;这里不明写a，b是哪种数据类型，而是交给编译器自动推导</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>显示指定类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mySwap&lt;int&gt;(a, b);   &#x2F;&#x2F;在&lt;&gt;中指明数据类型</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>总结：</p>
<ul>
<li>函数模板利用关键字template</li>
<li>使用函数模板2种方式：自动类型推导、显示指定类型</li>
<li>模板的目的：提到复用性，将类型参数化</li>
</ul>
<h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T，才可以使用</li>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<p><strong>示例1：</strong></p>
<p>错误写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 10;</span><br><span class="line">char b &#x3D; &#39;20&#39;;</span><br><span class="line">mySwap(a, b);  &#x2F;&#x2F;数据类型不一致！！！报错</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(void)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;测试函数</span><br><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">	func();&#x2F;&#x2F;报错，因为未指定数据类型</span><br><span class="line">	func&lt;int&gt;();&#x2F;&#x2F;正确：为了解决上述问题，可以给T一个数据类型如int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序函数，可以对不同数据类型数组进行排序</li>
<li>排序规定：从小到大，排序算法为选择排序</li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; &#x2F;&#x2F;声明一个模板，T是一个通用数据类型</span><br><span class="line">void sort(T a[], int len)</span><br><span class="line">&#123;</span><br><span class="line">	int min;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; len - 1; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min &#x3D; i;</span><br><span class="line">		for (int j &#x3D; i + 1; j &lt; len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (a[j] &lt; a[min])</span><br><span class="line">			&#123;</span><br><span class="line">				min &#x3D; j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (min !&#x3D; i)</span><br><span class="line">		&#123;</span><br><span class="line">			mySwap(a[min], a[i]);&#x2F;&#x2F;这个函数在前面写过了</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; len; i++)  &#x2F;&#x2F;ps:最好把输出函数也封装成一个函数模板</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; &quot; &quot; ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char arr[] &#x3D; &quot;adbce&quot;;</span><br><span class="line">int num &#x3D; sizeof(arr) &#x2F; sizeof(char);</span><br><span class="line">sort(arr, num);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>  a b c d e</p>
<h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别</strong>：</p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例</strong>：</p>
<p>普通函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int myAdd01(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试函数</span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	char c &#x3D; &#39;c&#39;;</span><br><span class="line">	cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>109</p>
<p>分析：c对应的ASCII码是99，与10相加刚好等于109,发生了隐式类型转换</p>
<p>函数模板类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">int myAdd02(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试函数</span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	char c &#x3D; &#39;c&#39;;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;自动类型推导---不会发生隐式类型转换</span><br><span class="line">	cout &lt;&lt; myAdd02(a, c) &lt;&lt; endl;&#x2F;&#x2F;报错，参数不一致</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;显示指定类型---会发生隐式类型转换</span><br><span class="line">	cout&lt;&lt; myAddd02&lt;int&gt;(a, c) &lt;&lt; endl;&#x2F;&#x2F;正确，成功输出109</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="1-2-5-普通函数和函数模板的调用规则"><a href="#1-2-5-普通函数和函数模板的调用规则" class="headerlink" title="1.2.5 普通函数和函数模板的调用规则"></a>1.2.5 普通函数和函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数皆可实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<p>1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void myPrint(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;普通函数的调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;函数模板&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	int b &#x3D; 20;</span><br><span class="line">	myPrint(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：普通函数的调用</p>
<p>2.</p>
<p>修改上述代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myPrint&lt;&gt;(a,b);&#x2F;&#x2F;通过空模板强制调用模板函数</span><br></pre></td></tr></table></figure>
<p>结果：函数模板</p>
<p>3.</p>
<p>在上述代码增加一个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void myPrint(T a, T b, T c)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;函数模板的重载&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myPrint&lt;&gt;(a,b,100);	</span><br></pre></td></tr></table></figure>
<p>结果：函数模板的重载</p>
<p>4.</p>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myPrint&lt;&gt;(&#39;a&#39;, &#39;b&#39;);&#x2F;&#x2F;如果函数模板可以产生更好的匹配，优先调用函数模板</span><br></pre></td></tr></table></figure>




<p>总结：既然提供了函数模板，最好不要提供普通函数，以免出现二义性。</p>
<h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p>局限性：模板的通用性并不是万能的</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	a &#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a &gt; b)</span><br><span class="line">	&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行。</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong>。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_name &#x3D; name;</span><br><span class="line">		m_age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_name;</span><br><span class="line">	int m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对比两个数据是否相等</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool myCompare(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	if (a &#x3D;&#x3D; b)</span><br><span class="line">	&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	int a &#x3D; 10;</span><br><span class="line">	int b &#x3D; 20;</span><br><span class="line">	bool ret &#x3D; myCompare(a, b);</span><br><span class="line"></span><br><span class="line">	if (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a&#x3D;&#x3D;b&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;a!&#x3D;b&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重载格式：先写template，再写尖括号</span><br><span class="line">template&lt;&gt; bool myCompare(Person&amp; p1, Person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">	if (p1.m_age &#x3D;&#x3D; p2.m_age &amp;&amp; p1.m_name &#x3D;&#x3D; p2.m_name)</span><br><span class="line">	&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person p1(&quot;Tom&quot;, 10);</span><br><span class="line">	Person p2(&quot;Tom&quot;, 20);</span><br><span class="line"></span><br><span class="line">	bool ret &#x3D; myCompare(p1, p2);</span><br><span class="line">	if (ret)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：建立一个同类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>template—–声明创建模板</p>
<p>typename—表明其后的符号是一种数据类型，可以用class代替</p>
<p>   T————-通用的数据类型，名称可以替换，通常为大写字母</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;类模板，要有两个数据类型模板</span><br><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_name &#x3D; name;</span><br><span class="line">		m_age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void showPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;name:&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot; age:&quot; &lt;&lt; this-&gt;m_age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_name;</span><br><span class="line">	AgeType m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt; p1(&quot;Tom&quot;, 10);</span><br><span class="line">	p1.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-3-2-类模板与函数模板的区别"><a href="#1-3-2-类模板与函数模板的区别" class="headerlink" title="1.3.2 类模板与函数模板的区别"></a>1.3.2 类模板与函数模板的区别</h4><p>主要有两点:</p>
<p>​    1.类模板没有自动类型推导的使用方式</p>
<p>​    2.类模板在模板参数列表中可以有默认参数</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;类模板</span><br><span class="line">template&lt;class NameType,class AgeType &#x3D; int&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_name &#x3D; name;</span><br><span class="line">		m_age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void showPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;name:&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot; age:&quot; &lt;&lt; this-&gt;m_age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_name;</span><br><span class="line">	AgeType m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string&gt; p1(&quot;Tom&quot;, 10);&#x2F;&#x2F;没有指明数据类型就使用默认数据类型</span><br><span class="line">	p1.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>类模板实例化的对象，向函数传参的方式</p>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入类型———直接显示对象的数据类型</li>
<li>参数模板化————将对象中的参数变为模板进行传递</li>
<li>整个类模板化———将这个对象类型 模板化进行传递</li>
</ol>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;类模板</span><br><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(NameType name, AgeType age)</span><br><span class="line">	&#123;</span><br><span class="line">		m_name &#x3D; name;</span><br><span class="line">		m_age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void showPerson()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;name:&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot; age:&quot; &lt;&lt; this-&gt;m_age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameType m_name;</span><br><span class="line">	AgeType m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1.指定传入类型</span><br><span class="line">void printperson1(Person&lt;string, int&gt;&amp; p1)</span><br><span class="line">&#123;</span><br><span class="line">	p1.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.参数模板化</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void printperson2(Person&lt;T1, T2&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.整个类模板化</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void printperson3(T&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">	p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test03(void)</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt; p(&quot;bluesgler&quot;, 17);</span><br><span class="line">	printperson3(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string,int&gt; p1(&quot;Tom&quot;, 10);</span><br><span class="line">	printperson1(p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02(void)</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt; p(&quot;Lriver&quot;, 17);</span><br><span class="line">	printperson2(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种，指定传入的类型</li>
</ul>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定父类的T类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指出父类中T的类型，子类也需要变为类模板</li>
</ul>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Class Son public Base  &#x2F;&#x2F;报错，必须要知道父类中的T类型才能继承给子类</span><br><span class="line">class Son :public Base&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果想灵活指定父类中T类型，子类也需要变类模板</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class Son2 :public Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Son2()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;T1的类型为：&quot; &lt;&lt; typeid(T1).name &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;T2的类型为：&quot; &lt;&lt; typeid(T2).name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	Son2&lt;int, char&gt;S2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(T1 name, T2 age);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void showPerson();</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数类外实现</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">Person&lt;T1,T2&gt;::Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_Name &#x3D; name;</span><br><span class="line">	this-&gt;m_Age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数类外实现</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void Person&lt;T1, T2&gt;::showPerson()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt;this-&gt;m_Age&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt;p1(&quot;Tom&quot;, 10);</span><br><span class="line">	p1.showPerson();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>问题：</p>
<ul>
<li>类模板中成员函数创建时机在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>way1：直接包含.cpp源文件</li>
<li>way2：将声明和实现写到同一个文件中，并更改后缀名为.hpp,hpp是约定的名称，并不是强制</li>
</ul>
<p>示例：</p>
<p>person.h中的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person(T1 name, T2 age);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void showPerson();</span><br><span class="line"></span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>person.cpp中的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;person.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;m_Name &#x3D; name;</span><br><span class="line">	this-&gt;m_Age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数类外实现</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void Person&lt;T1, T2&gt;::showPerson()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>含有main函数的.cpp中的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;person.h&quot;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt;p1(&quot;Tom&quot;, 10);</span><br><span class="line">	p1.showPerson();</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	return 0;</span><br></pre></td></tr></table></figure>
<p>运行一下，发生报错了，怎么回事呢？</p>
<p>因为类模板中成员函数在调用时才创建，编译器预先是读不到person.h和person.cpp中的部分代码，因此出错。</p>
<p>这里有两种解决方法：</p>
<p>1.直接在main函数中包含person.cpp文件，即用person.cpp替换person.h</p>
<p>2.将.h和.cpp中的内容写到一起，将后缀名改为.hpp文件</p>
<p>总结：</p>
<p>主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>类模板配合友元函数的类内和类外实现</p>
<p>全局函数类内实现-直接在类内声明友元即可</p>
<p>全局函数类外实现-需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提前让编译器知道Person类的存在</span><br><span class="line">template&lt;class T1, class t2&gt;</span><br><span class="line">class Person;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类外实现</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void printPerson2(Person&lt;T1, T2&gt;p)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;类型---姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot;类外---年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;全局函数 类内实现</span><br><span class="line">	friend void printPerson(Person&lt;T1, T2&gt;p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p.m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;全局函数 类外实现</span><br><span class="line">	&#x2F;&#x2F;加空模板的参数列表</span><br><span class="line">	&#x2F;&#x2F;如果全局函数是类外实现，务必让编译器提前知道这个函数存在</span><br><span class="line">	friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt;p);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Person(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_Name &#x3D; name;</span><br><span class="line">		this-&gt;m_Age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数在类内实现</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt;p(&quot;Tom&quot;, 30);</span><br><span class="line"></span><br><span class="line">	printPerson(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	Person&lt;string, int&gt;p2(&quot;Lriver&quot;, 80);</span><br><span class="line">	printPerson2(p2);</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	test02();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述：实现一个通用的数据类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator= 防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数据中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通用数组类</span><br><span class="line">#pragma once</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class MyArray</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;有参构造 参数 容量</span><br><span class="line">	MyArray(int capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Myarray 有参构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">		this-&gt;m_Capacity &#x3D; capacity;</span><br><span class="line">		this-&gt;m_Size &#x3D; 0;</span><br><span class="line">		this-&gt;pAddress &#x3D; new T[this-&gt;m_Capacity];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;拷贝构造</span><br><span class="line">	MyArray(const MyArray&amp; arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Myarray 拷贝构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">		this-&gt;m_Capacity &#x3D; arr.m_Capacity;</span><br><span class="line">		this-&gt;m_Size &#x3D; arr.m_Size;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;深拷贝</span><br><span class="line">		this-&gt;pAddress &#x3D; new T[arr.m_Capacity];</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;将arr中的数据都拷贝过来</span><br><span class="line">		for (int i &#x3D; 0; i &lt; this-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			this-&gt;pAddress[i] &#x3D; arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;operator&#x3D; 防止浅拷贝问题</span><br><span class="line">	MyArray&amp; operator&#x3D;(const MyArray&amp; arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;operator&#x3D;调用&quot; &lt;&lt; endl;</span><br><span class="line">		&#x2F;&#x2F;先判断原来堆区是否有数据，如果有先释放</span><br><span class="line">		if (this-&gt;pAddress !&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			delete[] this-&gt;pAddress;</span><br><span class="line">			this-&gt;pAddress &#x3D; NULL;</span><br><span class="line">			this-&gt;m_Capacity &#x3D; 0;</span><br><span class="line">			this-&gt;m_Size &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;深拷贝</span><br><span class="line">		this-&gt;m_Capacity &#x3D; arr.m_Capacity;</span><br><span class="line">		this-&gt;m_Size &#x3D; arr.m_Size;</span><br><span class="line">		this-&gt;pAddress &#x3D; new T[arr.m_Capacity];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; this-&gt;m_Size; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			this-&gt;pAddress[i] &#x3D; arr.pAddress[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;尾插法</span><br><span class="line">	void Push_Back(const T&amp; val)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;判断容量是否等于大小</span><br><span class="line">		if (this-&gt;m_Capacity &#x3D;&#x3D; this-&gt;m_Size)</span><br><span class="line">		&#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;pAddress[this-&gt;m_Size] &#x3D; val;&#x2F;&#x2F;在数组末尾插入数据</span><br><span class="line">		this-&gt;m_Size++;&#x2F;&#x2F;更新数组大小</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;尾删法</span><br><span class="line">	void Pop_Back()</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;让用户访问不到最后一个元素，即为尾删，逻辑删除</span><br><span class="line">		if (this-&gt;m_Size &#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		this-&gt;m_Size--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;通过下标方式访问数组中的元素</span><br><span class="line">	T&amp; operator[](int index)</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;pAddress[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;返回数组容量</span><br><span class="line">	int getCapacity()</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;m_Capacity;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;返回数组大小</span><br><span class="line">	int getSize()</span><br><span class="line">	&#123;</span><br><span class="line">		return this-&gt;m_Size;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;析构函数</span><br><span class="line">	~MyArray()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		if (this-&gt;pAddress !&#x3D; NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;Myarray 有参析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">			delete[] this-&gt;pAddress;</span><br><span class="line">			this-&gt;pAddress &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	T * pAddress; &#x2F;&#x2F;指针指向堆区开辟的真实数组</span><br><span class="line"></span><br><span class="line">	int m_Capacity;&#x2F;&#x2F;数组容量</span><br><span class="line"></span><br><span class="line">	int m_Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试整型数据</p>
<p>含main函数中的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;MyArray.hpp&quot;</span><br><span class="line"></span><br><span class="line">void printIntArray(MyArray &lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; arr.getSize(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	MyArray&lt;int&gt;arr1(5);</span><br><span class="line">	</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;利用尾插法向数组中插入数据</span><br><span class="line">		arr1.Push_Back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;arr1的打印输出为：&quot; &lt;&lt; endl;</span><br><span class="line">	printIntArray(arr1);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;arr1的容量为：&quot; &lt;&lt;arr1.getCapacity() &lt;&lt;  endl;</span><br><span class="line">	cout &lt;&lt; &quot;arr1的容量为：&quot; &lt;&lt; arr1.getSize() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	MyArray&lt;int&gt;arr2(arr1);</span><br><span class="line">	cout &lt;&lt; &quot;arr2的打印输出：&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	printIntArray(arr2);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;尾删</span><br><span class="line">	arr2.Pop_Back();</span><br><span class="line">	cout &lt;&lt; &quot;arr2尾删后：&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;arr2的容量：&quot; &lt;&lt; arr2.getCapacity() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;arr2的大小为：&quot; &lt;&lt; arr2.getSize() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出结果：</p>
<p>Myarray 有参构造函数调用<br>arr1的打印输出为：<br>0<br>1<br>2<br>3<br>4<br>arr1的容量为：5<br>arr1的容量为：5<br>Myarray 拷贝构造函数调用<br>arr2的打印输出：<br>0<br>1<br>2<br>3<br>4<br>arr2尾删后：<br>arr2的容量：5<br>arr2的大小为：4<br>Myarray 有参析构函数调用<br>Myarray 有参析构函数调用</p>
<hr>
<p>测试自定义数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;测试自定义数据类型</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person() &#123;&#125;;</span><br><span class="line">	Person(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_Name &#x3D; name;</span><br><span class="line">		this-&gt;m_Age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void printPersonArray(MyArray&lt;Person&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; arr.getSize(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; arr[i].m_Name &lt;&lt; &quot;\t年龄：&quot; &lt;&lt; arr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	MyArray&lt;Person&gt; arr(10);</span><br><span class="line"></span><br><span class="line">	Person p1(&quot;孙悟空&quot;, 999);</span><br><span class="line">	Person p2(&quot;花花&quot;, 810);</span><br><span class="line">	Person p3(&quot;Lriver&quot;, 17);</span><br><span class="line">	Person p4(&quot;bulesgler&quot;, 17);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;将数据插入到数组中</span><br><span class="line">	arr.Push_Back(p1);</span><br><span class="line">	arr.Push_Back(p2);</span><br><span class="line">	arr.Push_Back(p3);</span><br><span class="line">	arr.Push_Back(p4);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;打印数组</span><br><span class="line">	printPersonArray(arr);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 输出容量</span><br><span class="line">	cout &lt;&lt; &quot;arr容量为：&quot; &lt;&lt; arr.getCapacity() &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;输出大小</span><br><span class="line">	cout &lt;&lt; &quot;arr大小为：&quot; &lt;&lt; arr.getSize() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>Myarray 有参构造函数调用<br>姓名：孙悟空    年龄：999<br>姓名：花花      年龄：810<br>姓名：Lriver    年龄：17<br>姓名：bulesgler 年龄：17<br>arr容量为：10<br>arr大小为：4<br>Myarray 有参析构函数调用</p>
<h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul>
<li>长久以来，软件界一直希望建立一种可重复利用的东西</li>
<li>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></li>
<li>大多数情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</li>
<li>为了建立数据结构和算法的一套标准，诞生了STL</li>
</ul>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul>
<li>STL（Standard Template Library,<strong>标准模板库</strong>）</li>
<li>STL 从广义上分为：<strong>容器（container）</strong>，<strong>算法（algorithm）</strong>，<strong>迭代器（iterator）</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接</li>
<li>STL 几乎所有代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL 大体分为六大组件，分别是：<strong>容器</strong>、<strong>算法</strong>、<strong>迭代器</strong>、<strong>仿函数</strong>、<strong>适配器（配接器）</strong>、<strong>空间配置器</strong></p>
<p>1.容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。</p>
<p>2.算法：各种常用的算法，如sort、find、copy、for_each等。</p>
<p>3.迭代器：扮演了容器与算法之间的胶合剂。</p>
<p>4.仿函数：行为类似函数，可作为算法的某种策略。</p>
<p>5.适配器：一种用来修饰容器或仿函数或迭代器接口的函数。</p>
<p>6.空间配置器：负责空间的分配与管理。</p>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4 STL中容器、算法、迭代器"></a>2.4 STL中容器、算法、迭代器</h3><p><strong>容器</strong>：置物之所也。</p>
<p>STL <strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组，链表，树，栈，队列，集合，映射表等</p>
<p>这些容器分为：<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p>
<ul>
<li><strong>序列式容器</strong>：强调值的排序，序列式容器中每个元素均有固定的位置</li>
<li><strong>关联式容器</strong>：二叉树结构，各元素之间没有样的物理上的顺序关系</li>
</ul>
<p><strong>算法</strong>：问题之解法也。</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法（Algorithms）</p>
<p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<ul>
<li>质变算法：运算过程中会更改区间内元素的内容。eg：拷贝，替换，删除等。</li>
<li>非质变算法：运算过程中不会更改区间内元素内容，例如查找，计数，遍历。寻找极值等等。</li>
</ul>
<p><strong>迭代器</strong>：容器和算法之间的粘合剂</p>
<p>提供一种方法，使之能依序寻访某个容器的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器。</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数组的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数组的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++，–</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，随机迭代器。</p>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL 中最常用容器为Vector，可以理解为数组，下面我们将介绍如何向这个容器中插入数据，并遍历这个容器。</p>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：<code>vector</code></p>
<p>算法：<code>for_each</code></p>
<p>迭代器：<code>vector&lt;int&gt;::iterator</code></p>
<p>示例：</p>
<p>vector容器存放内置数据类型</p>
<p>第一种遍历方式，稍微有些复杂，注意使用vector容器要包含vector头文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;创建了一个vector容器、数组</span><br><span class="line">	vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;向容器中插入数据</span><br><span class="line">	v.push_back(10);</span><br><span class="line">	v.push_back(20);</span><br><span class="line">	v.push_back(30);</span><br><span class="line">	v.push_back(40);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;通过迭代器访问容器中的类型</span><br><span class="line">	vector&lt;int&gt;::iterator itBegin &#x3D; v.begin();  &#x2F;&#x2F;起始迭代器，指向容器中第一个元素</span><br><span class="line">	vector&lt;int&gt;::iterator itEnd &#x3D; v.end();  &#x2F;&#x2F;结束迭代器，指向容器中最后一个元素的下一个元素</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;第一种遍历方式</span><br><span class="line">	while (itBegin !&#x3D; itEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;把迭代器当成指针来使用，因此解引用</span><br><span class="line">		cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">		itBegin++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种遍历方式，for循环 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第二种遍历方式</span><br><span class="line">	for (vector&lt;int&gt;::iterator it &#x3D; v.begin() ; it !&#x3D; v.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>第三种遍历方式，利用STL提供遍历算法for_each,要包含头文件algorithm，还有提供一个打印的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第三种遍历方式</span><br><span class="line">	for_each(v.begin(), v.end(), myPrint);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void myPrint(int val)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;vector容器中存放自定义数据类型</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(string name, int age)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_Name &#x3D; name;</span><br><span class="line">		this-&gt;m_Age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">	Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">	Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">	Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">	Person p4(&quot;ddd&quot;, 40);</span><br><span class="line">	Person p5(&quot;eee&quot;, 50);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;向容器中添加数据</span><br><span class="line">	v.push_back(p1);</span><br><span class="line">	v.push_back(p2);</span><br><span class="line">	v.push_back(p3);</span><br><span class="line">	v.push_back(p4);</span><br><span class="line">	v.push_back(p5);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;遍历容器中的数据</span><br><span class="line">	for (vector&lt;Person&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot;\t年龄：&quot; &lt;&lt; (*it).m_Age &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot;\t年龄：&quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;&#x2F;&#x2F;也可以这样写</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存放自定义类型指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;存放自定义类型指针</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">	Person p1(&quot;aaa&quot;, 10);</span><br><span class="line">	Person p2(&quot;bbb&quot;, 20);</span><br><span class="line">	Person p3(&quot;ccc&quot;, 30);</span><br><span class="line">	Person p4(&quot;ddd&quot;, 40);</span><br><span class="line">	Person p5(&quot;eee&quot;, 50);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;向容器中添加数据</span><br><span class="line">	v.push_back(&amp;p1);</span><br><span class="line">	v.push_back(&amp;p2);</span><br><span class="line">	v.push_back(&amp;p3);</span><br><span class="line">	v.push_back(&amp;p4);</span><br><span class="line">	v.push_back(&amp;p5);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;遍历容器</span><br><span class="line">	for (vector&lt;Person*&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;这里尖括号里面是Person *类型，解引用以后就是Person*类型，是个指针，要访问元素，还要加箭头</span><br><span class="line">		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it)-&gt;m_Name &lt;&lt; &quot;年龄：&quot; &lt;&lt; (*it)-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-5-3-Vector-容器嵌套容器"><a href="#2-5-3-Vector-容器嵌套容器" class="headerlink" title="2.5.3 Vector 容器嵌套容器"></a>2.5.3 Vector 容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;vector&lt;int&gt;&gt;v;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建小容器</span><br><span class="line">	vector&lt;int&gt;v1;</span><br><span class="line">	vector&lt;int&gt;v2;</span><br><span class="line">	vector&lt;int&gt;v3;</span><br><span class="line">	vector&lt;int&gt;v4;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;向小容器中添加数据</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.push_back(i + 1);</span><br><span class="line">		v2.push_back(i + 2);</span><br><span class="line">		v3.push_back(i + 3);</span><br><span class="line">		v4.push_back(i + 4);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;将小容器插入到大容器中</span><br><span class="line">	v.push_back(v1);</span><br><span class="line">	v.push_back(v2);</span><br><span class="line">	v.push_back(v3);</span><br><span class="line">	v.push_back(v4);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;通过大容器，把所有数据遍历一遍</span><br><span class="line">	for (vector&lt;vector&lt;int&gt;&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;(*it)--------容器vector&lt;int&gt;</span><br><span class="line">		for (vector&lt;int&gt;::iterator vit &#x3D; (*it).begin(); vit !&#x3D; (*it).end(); vit++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	test01();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-1-STL-常用容器"><a href="#3-1-STL-常用容器" class="headerlink" title="3.1 STL-常用容器"></a>3.1 STL-常用容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p>本质：</p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p>*<em>string和char</em>区别:**</p>
<ul>
<li>char* 是一个指针</li>
<li>string是一个类，类内部封装char<em>，管理职工字符串，是一个char</em>型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string类内部封装了很多成员方法</p>
<p>eg：查找find，拷贝copy，删除delete替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p>
<ul>
<li><p><code>string();</code>                                            //    创建一个空的字符串，eg：string str；</p>
<p><code>string(const char* s);</code>                //使用字符串s初始化</p>
</li>
<li><p><code>string(const string &amp; str);</code>     //使用一个string对象初始化另一个string对象</p>
</li>
<li><p><code>string(int n, char c);</code>                //使用n个字符c初始化</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string s1;   &#x2F;&#x2F;默认构造，创建一个空的字符串</span><br><span class="line"></span><br><span class="line">	const char* str &#x3D; &quot;hello world&quot;;</span><br><span class="line">	string s2(str);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;s2 &#x3D; &quot; &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string s3(s2);</span><br><span class="line">	cout &lt;&lt; &quot;s3 &#x3D; &quot; &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string s4(10, &#39;a&#39;);</span><br><span class="line">	cout &lt;&lt; &quot;s4 &#x3D; &quot; &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>s2 = hello world<br>s3 = hello world<br>s4 = aaaaaaaaaa</p>
<p>总结：string的多种构造方式没有可比性，灵活使用即可。</p>
<h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator = (const char * s);</code>      //char * 类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator = (const string &amp;s); </code>   //把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator = (char c);</code>                      //字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串串</li>
<li><code>string&amp; assign(const char *s, int n);</code>    //把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1;</span><br><span class="line">	str1 &#x3D; &quot;hello world&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2;</span><br><span class="line">	str2 &#x3D; str1;</span><br><span class="line">	cout &lt;&lt; &quot;str2 &#x3D; &quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3;</span><br><span class="line">	str3 &#x3D; &#39;a&#39;;</span><br><span class="line">	cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;&#x2F;&#x2F;单个字符赋值</span><br><span class="line"></span><br><span class="line">	string str4;</span><br><span class="line">	str4.assign(&quot;hello C++&quot;);</span><br><span class="line">	cout &lt;&lt; &quot;str4 &#x3D; &quot; &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str5;</span><br><span class="line">	str5.assign(&quot;HELLO C++&quot;, 7);</span><br><span class="line">	cout &lt;&lt; &quot;str5 &#x3D; &quot; &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str6;</span><br><span class="line">	str6.assign(str5);</span><br><span class="line">	cout &lt;&lt; &quot;str6 &#x3D; &quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str7;</span><br><span class="line">	str7.assign(10, &#39;w&#39;);</span><br><span class="line">	cout &lt;&lt; &quot;str7 &#x3D; &quot; &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>str1 = hello world<br>str2 = hello world<br>str3 = a<br>str4 = hello C++<br>str5 = HELLO C<br>str6 = HELLO C<br>str7 = wwwwwwwwww</p>
<p>总结：</p>
<p>string的赋值方式很多，<code>operator=</code> 这种方式是比较实用的</p>
<h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p>功能描述：</p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>string&amp; operator+=(const char * str);</code>         //重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                 //重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>       //重载+=操作符</li>
<li><code>string&amp; append(const string&amp; str);</code>               //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>         //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                    //同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 &#x3D; &quot;我&quot;;</span><br><span class="line">	str1 +&#x3D; &quot;爱米切氏凤头鹦鹉&quot;;</span><br><span class="line">	str1 +&#x3D; &quot;!&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str2 &#x3D; &quot;也爱小虎皮！&quot;;</span><br><span class="line">	str1 +&#x3D; str2;</span><br><span class="line">	cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string str3 &#x3D; &quot;I &quot;;</span><br><span class="line">	str3.append(&quot;love &quot;);</span><br><span class="line">	cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	str3.append(&quot;this word!dfosh&quot;, 10);</span><br><span class="line">	cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str3.append(str2);</span><br><span class="line">	cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str3.append(str3, 0, 4);&#x2F;&#x2F;截取字符，参数1是开始截取的位置，参数2是截取是长度，空格也算是一个字符</span><br><span class="line">	cout &lt;&lt; &quot;str3 &#x3D; &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>str1 = 我爱米切氏凤头鹦鹉!<br>str1 = 我爱米切氏凤头鹦鹉!也爱小虎皮！<br>str3 = I love<br>str3 = I love this word!<br>str3 = I love this word!也爱小虎皮！<br>str3 = I love this word!也爱小虎皮！I lo</p>
<h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p>功能描述：</p>
<ul>
<li>查找：查找指定的字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>                              //查找str第一次出现位置，从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0 ) const; </code>                                    //查找s第一次出现的位置，从pos开始查找</li>
<li><code>int find(const char s, int pos, int n) const;</code>                                 //从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const;</code>                                       //查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const; </code>                    //查找str最后一次位置，从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>                            //查找str最后一次出现位置，从pos开始查找</li>
<li><code>int rfind(const char s, int pos, int n) const; </code>                              //从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;</code>                                    //查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>                   //替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                             //替换从pos开始的n个字符为字符串s</li>
</ul>
<p>示例：</p>
<p>查找—–find</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 &#x3D; &quot;abcdefg&quot;;</span><br><span class="line"></span><br><span class="line">	int pos &#x3D; str1.find(&quot;df&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if (pos &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;未找到字符串&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;找到字符串，pos &#x3D; &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找—–rfind</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 &#x3D; &quot;abcdefgde&quot;;</span><br><span class="line">	int pos &#x3D; str1.rfind(&quot;de&quot;);</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;pos &#x3D; &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find和rfind的区别：</p>
<ul>
<li>rfind从右往左查</li>
<li>find从左往右查</li>
</ul>
<p>替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 &#x3D; &quot;abcdefgde&quot;;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;从1号位置起3个字符替换为“1111”</span><br><span class="line">	str1.replace(1, 3, &quot;1111&quot;);</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>str1 = a1111efgde</p>
<p>总结：</p>
<ul>
<li>find查找从左往右，rfind查找从右往左</li>
<li>find找到字符串后返回第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p>功能描述：</p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p>比较方式：</p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回 0    &gt; 返回1    &lt; 返回-1</p>
<p>函数原型：</p>
<ul>
<li><code>int compare(const string &amp;s) const;</code>        //与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>           //与字符串s比较</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 &#x3D; &quot;xello&quot;;</span><br><span class="line">	string str2 &#x3D; &quot;hello&quot;;</span><br><span class="line">	</span><br><span class="line">	if (str1.compare(str2) &#x3D;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;str1 &#x3D; str2&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (str1.compare(str2) &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;str1 &gt; str2&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;str1 &lt; str2&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：字符串对比主要是比较两个字符串是否相等，判断谁大谁小意义不大</p>
<h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n);</code>            //通过[]方式取字符</li>
<li><code>char&amp; at(int n); </code>                            //通过at方式获取字符</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 &#x3D; &quot;hello&quot;;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1.通过[]访问单个字符</span><br><span class="line">	for (int i &#x3D; 0; i &lt; str1.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str1[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2.通过at方式访问单个字符</span><br><span class="line">	for (int i &#x3D; 0; i &lt; str1.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str1.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;修改单个字符</span><br><span class="line">	str1[0] &#x3D; &#39;x&#39;;</span><br><span class="line">	cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	str1.at(1) &#x3D; &#39;x&#39;;</span><br><span class="line">	cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-1-8string插入和删除"><a href="#3-1-8string插入和删除" class="headerlink" title="3.1.8string插入和删除"></a>3.1.8string插入和删除</h4><p>功能描述：</p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);</code>            //插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str);</code>     //插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>             //在指定位置插入n个c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>             //删除从Pos开始的n个字符</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 &#x3D; &quot;hello&quot;;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;插入</span><br><span class="line">	str1.insert(1, &quot;1111&quot;);</span><br><span class="line">	cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;输出：str1 &#x3D; h1111ello</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;删除</span><br><span class="line">	str1.erase(1, 4);&#x2F;&#x2F;参数1：从哪开始删；参数2：删多少个字符</span><br><span class="line">	cout &lt;&lt; &quot;str1 &#x3D; &quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	&#x2F;&#x2F;输出：str1 &#x3D; hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p>功能描述：</p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个自发组成的字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 &#x3D; &quot;abcdef&quot;;</span><br><span class="line">	string subStr &#x3D; str1.substr(1, 3);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;subStr &#x3D; &quot; &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实用操作</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">	string email &#x3D; &quot;huahua@sina.com&quot;;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;从邮件地址中 获取 用户名信息</span><br><span class="line"></span><br><span class="line">	int pos &#x3D; email.find(&quot;@&quot;);</span><br><span class="line">	cout &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string userName &#x3D; email.substr(0, pos);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; userName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>总结：灵活运用求子串功能，可以在实际开发中获取有效信息</p>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p>功能：</p>
<ul>
<li>vector数据结构和数组非常相似，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处：数组是静态空间，而vector可以动态扩展</li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找到更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img src="/noteimg/vector.png"></p>
<ul>
<li>vector容器的迭代器是支持随机范围的迭代器</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
